<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="white" />
  <meta name="theme-color" content="#ffffff" />
  <title>GeoCanvas Classic</title>
  <style>
    :root {
      color-scheme: light;
      --toolbar-height: 56px;
      --sidebar-width: min(320px, 32vw);
      --accent: #3367d6;
      --border: #d9d9d9;
      --bg: #f8f8fb;
      --panel-bg: #ffffff;
      font-family: "Inter", "Segoe UI", sans-serif;
      --keyboard-offset: 0px;
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      background: var(--bg);
      color: #222;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    header {
      height: var(--toolbar-height);
      background: var(--panel-bg);
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 0 12px;
      flex-wrap: wrap;
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 600;
      letter-spacing: 0.01em;
      color: #3a3a3a;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
    }

    .brand * {
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
    }

    .brand svg {
      width: 28px;
      height: 28px;
      color: var(--accent);
    }

    .toolbar {
      display: flex;
      align-items: center;
      gap: 6px;
      flex: 1;
      min-width: 240px;
    }

    .tool-button {
      background: transparent;
      border: 1px solid transparent;
      border-radius: 12px;
      padding: 6px 8px;
      min-width: 44px;
      min-height: 44px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: background 0.15s ease, border 0.15s ease, color 0.15s ease;
      color: #404040;
      cursor: pointer;
    }

    .tool-button svg {
      width: 22px;
      height: 22px;
      stroke: currentColor;
      fill: none;
      stroke-width: 1.8;
      vector-effect: non-scaling-stroke;
    }

    .tool-button.active {
      background: rgba(51, 103, 214, 0.12);
      border-color: rgba(51, 103, 214, 0.6);
      color: var(--accent);
    }

    .tool-button:hover {
      background: rgba(0,0,0,0.05);
    }

    .layout {
      flex: 1;
      display: flex;
      min-height: 0;
    }

    .sidebar {
      flex: 0 0 var(--sidebar-width);
      max-width: 400px;
      background: var(--panel-bg);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      transition: transform 0.25s ease;
      z-index: 2;
    }

    .sidebar.hidden {
      transform: translateX(calc(-1 * var(--sidebar-width)));
    }

    .sidebar.collapsed-desktop {
      display: none;
    }

    .sidebar-header {
      padding: 14px 16px 10px;
      font-weight: 600;
      font-size: 0.95rem;
      color: #555;
      display: flex;
      align-items: center;
      justify-content: space-between;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
    }

    .sidebar-header * {
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
    }

    .algebra-list {
      flex: 1;
      overflow: auto;
      padding: 0 12px 12px;
    }

    .algebra-item {
      background: rgba(0,0,0,0.03);
      border-radius: 12px;
      padding: 10px 12px;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .algebra-item.selected {
      background: rgba(51, 103, 214, 0.12);
      box-shadow: inset 0 0 0 1px var(--highlight-outline, rgba(51, 103, 214, 0.3));
    }

    .algebra-color {
      width: 12px;
      height: 12px;
      border-radius: 999px;
      flex: 0 0 auto;
    }

    .algebra-item.selected .algebra-color {
      box-shadow: 0 0 0 3px var(--highlight-glow, rgba(51, 103, 214, 0.2));
    }

    .algebra-label {
      flex: 1;
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      font-size: 0.92rem;
    }

    .algebra-label strong {
      font-weight: 600;
      color: #222;
    }

    .algebra-detail {
      color: #555;
    }

    .delete-button {
      flex: 0 0 auto;
      border: 1px solid transparent;
      background: transparent;
      border-radius: 10px;
      width: 32px;
      height: 32px;
      display: grid;
      place-items: center;
      cursor: pointer;
      color: #8a8a8a;
      transition: background 0.2s ease, color 0.2s ease;
    }

    .delete-button svg {
      width: 18px;
      height: 18px;
      stroke-width: 1.8;
      stroke: currentColor;
      fill: none;
    }

    .delete-button:hover {
      background: rgba(0,0,0,0.08);
      color: #444;
    }

    .graph-container {
      flex: 1;
      position: relative;
      background: var(--panel-bg);
      display: flex;
      flex-direction: column;
      min-width: 0;
    }

    canvas {
      width: 100%;
      height: 100%;
      flex: 1;
      touch-action: none;
      background: #fff;
      display: block;
    }

    .axis-label {
      position: absolute;
      font-size: 0.75rem;
      color: #666;
      pointer-events: none;
    }

    .command-bar {
      border-top: 1px solid var(--border);
      background: var(--panel-bg);
      padding: 10px 12px;
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .command-bar > span {
      font-size: 1.25rem;
      color: #777;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      pointer-events: none;
    }

    .command-input {
      flex: 1;
      min-width: 220px;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px 14px;
      font-size: 0.95rem;
      background: #fff;
      transition: border 0.2s ease, box-shadow 0.2s ease;
    }

    .command-input:focus {
      outline: none;
      border-color: rgba(51, 103, 214, 0.6);
      box-shadow: 0 0 0 4px rgba(51, 103, 214, 0.15);
    }

    .command-button {
      border: 1px solid var(--border);
      background: #fff;
      border-radius: 12px;
      width: 44px;
      height: 44px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: #444;
      cursor: pointer;
      transition: border 0.2s ease, box-shadow 0.2s ease, color 0.2s ease;
    }

    .command-button svg {
      width: 22px;
      height: 22px;
      stroke-width: 1.8;
      stroke: currentColor;
      fill: none;
    }

    .command-button.active {
      border-color: rgba(51, 103, 214, 0.6);
      box-shadow: 0 0 0 3px rgba(51, 103, 214, 0.15);
      color: var(--accent);
    }

    .badge {
      background: rgba(51,103,214,0.1);
      color: var(--accent);
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 0.8rem;
      font-weight: 600;
    }

    .math-keyboard {
      background: rgba(244, 244, 251, 0.98);
      border-top: 1px solid var(--border);
      padding: 16px;
      display: none;
      flex-direction: column;
      gap: 12px;
      box-shadow: 0 -12px 40px rgba(0,0,0,0.08);
      border-radius: 20px 20px 0 0;
      width: min(720px, 100%);
      margin: 0 auto;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
    }

    .math-keyboard.active {
      display: flex;
    }

    .math-keyboard.desktop-floating {
      position: fixed;
      right: 24px;
      bottom: 24px;
      border-radius: 18px;
      border: 1px solid rgba(120, 132, 170, 0.24);
      box-shadow: 0 16px 32px rgba(15, 23, 42, 0.18);
      margin: 0;
      width: min(420px, calc(100% - 32px));
      max-height: calc(100vh - 32px);
      overflow: auto;
      z-index: 5;
    }

    .math-keyboard.desktop-floating.active {
      display: flex;
    }

    .math-keyboard.dragging {
      cursor: grabbing;
    }

    .math-keyboard.dragging .keyboard-handle {
      cursor: grabbing;
    }

    body.keyboard-open {
      overflow: hidden;
    }

    .quick-actions {
      display: none;
      margin-top: 8px;
      gap: 8px;
    }

    .keyboard-header {
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
    }

    .keyboard-handle {
      width: 72px;
      height: 6px;
      border-radius: 999px;
      background: rgba(80, 90, 120, 0.25);
      cursor: grab;
      touch-action: none;
    }

    .keyboard-handle:active {
      cursor: grabbing;
    }

    .keyboard-tabs {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .keyboard-tab {
      flex: 0 0 auto;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.92);
      color: #555;
      padding: 8px 14px;
      border-radius: 999px;
      font-weight: 600;
      font-size: 0.85rem;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, border 0.2s ease;
    }

    .keyboard-tab.active {
      color: var(--accent);
      border-color: rgba(51,103,214,0.6);
      background: rgba(51,103,214,0.08);
    }

    .keyboard-rows {
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-height: 292px;
    }

    .keyboard-row {
      display: flex;
      gap: 8px;
      flex-wrap: nowrap;
      min-height: 52px;
    }

    .keyboard-key {
      flex: 1 1 0;
      min-width: 0;
      border: 1px solid rgba(67, 79, 110, 0.18);
      background: rgba(255,255,255,0.96);
      border-radius: 12px;
      min-height: 48px;
      min-width: 36px;
      font-size: clamp(0.85rem, 2.6vw, 1rem);
      font-weight: 600;
      color: #2d2d2d;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 6px 10px;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      white-space: nowrap;
    }

    .keyboard-key.small {
      flex: 0.7 1 0;
    }

    .keyboard-key.wide {
      flex: 1.6 1 0;
    }

    .keyboard-key.command {
      background: rgba(51, 103, 214, 0.08);
      color: var(--accent);
      border-color: rgba(51, 103, 214, 0.24);
    }

    .keyboard-key.command:hover {
      background: rgba(51, 103, 214, 0.15);
    }

    .keyboard-key:hover {
      background: rgba(51,103,214,0.08);
    }

    .keyboard-key:active {
      transform: scale(0.97);
      box-shadow: inset 0 0 0 2px rgba(51,103,214,0.2);
    }

    .floating-controls {
      position: absolute;
      right: 12px;
      top: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 1;
      align-items: flex-end;
    }

    .control-row {
      display: flex;
      gap: 8px;
    }

    .round-button {
      width: 42px;
      height: 42px;
      border-radius: 21px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.94);
      box-shadow: 0 8px 24px rgba(0,0,0,0.08);
      display: grid;
      place-items: center;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .round-button[disabled] {
      opacity: 0.45;
      cursor: default;
      box-shadow: none;
    }

    .round-button:hover:not([disabled]) {
      transform: translateY(-1px);
      box-shadow: 0 12px 30px rgba(0,0,0,0.12);
    }

    .round-button svg {
      width: 20px;
      height: 20px;
      stroke: #444;
      fill: none;
      stroke-width: 2;
    }

    @media (max-width: 920px) {
      :root {
        --sidebar-width: min(280px, 70vw);
      }

      body.sidebar-open::after {
        content: "";
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.28);
        pointer-events: none;
        z-index: 4;
      }

      .layout {
        position: relative;
      }

      .sidebar {
        position: fixed;
        top: 0;
        bottom: 0;
        left: 0;
        box-shadow: 12px 0 40px rgba(0,0,0,0.22);
        max-width: min(360px, 78vw);
        transform: translateX(-105%);
        z-index: 5;
      }

      body.sidebar-open .sidebar {
        transform: translateX(0);
      }

      .graph-container {
        flex: 1;
      }

      .sidebar.collapsed-desktop {
        display: flex;
      }

      .math-keyboard {
        box-shadow: 0 -8px 28px rgba(0,0,0,0.12);
        max-width: none;
        margin: 0;
      }

      .math-keyboard.active {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 6;
      }

      .keyboard-header {
        align-items: stretch;
      }

      .keyboard-handle {
        display: none;
      }

      .command-bar {
        position: sticky;
        bottom: var(--keyboard-offset, 0px);
        background: rgba(255,255,255,0.96);
        backdrop-filter: blur(12px);
        box-shadow: 0 -12px 24px rgba(0,0,0,0.12);
        z-index: 3;
      }

      .quick-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        padding: 10px 12px;
        background: rgba(255,255,255,0.95);
        border-top: 1px solid var(--border);
      }
    }

    @media (max-width: 600px) {
      header {
        gap: 8px;
        padding: 6px 10px;
        height: auto;
      }

      .brand {
        flex: 1;
      }

      .toolbar {
        order: 3;
        width: 100%;
        justify-content: flex-start;
      }

      .tool-button {
        min-width: 40px;
        min-height: 40px;
        border-radius: 10px;
      }

      .command-bar {
        padding: 10px;
      }
    }

    @media (min-width: 921px) {
      .math-keyboard {
        position: relative;
        border-radius: 24px;
        box-shadow: 0 -16px 48px rgba(0,0,0,0.1);
      }

      .math-keyboard.active {
        position: relative;
      }
    }

    .quick-action {
      border: 1px solid rgba(51,103,214,0.2);
      background: rgba(51,103,214,0.08);
      color: var(--accent);
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, border 0.2s ease, transform 0.2s ease;
    }

    .quick-action:hover {
      background: rgba(51,103,214,0.16);
    }

    .quick-action:active {
      transform: scale(0.97);
    }
  </style>
</head>
<body>
  <header>
    <button class="tool-button" id="toggle-sidebar" aria-label="Wissel algebra-paneel">
      <svg viewBox="0 0 24 24" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M4 4h16" />
        <path d="M4 12h10" />
        <path d="M4 20h16" />
      </svg>
    </button>
    <div class="brand">
      <svg viewBox="0 0 32 32" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="16" cy="16" r="10" opacity="0.3" />
        <path d="M16 6v4" />
        <path d="M16 22v4" />
        <path d="M6 16h4" />
        <path d="M22 16h4" />
        <circle cx="16" cy="16" r="4" />
      </svg>
      GeoCanvas Classic
    </div>
    <div class="toolbar" role="toolbar" aria-label="Tekengereedschap">
      <button class="tool-button active" data-tool="move" aria-label="Verplaats gereedschap">
        <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
          <path d="M6 4 18 16l-5 1.5 1.5 5L11 17.5 8.5 20l1.5-5z" />
        </svg>
      </button>
      <button class="tool-button" data-tool="point" aria-label="Punt gereedschap">
        <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="12" cy="12" r="4" />
        </svg>
      </button>
      <button class="tool-button" data-tool="segment" aria-label="Lijnstuk gereedschap">
        <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
          <path d="M6 18 18 6" />
          <circle cx="6" cy="18" r="2.5" />
          <circle cx="18" cy="6" r="2.5" />
        </svg>
      </button>
      <button class="tool-button" data-tool="line" aria-label="Rechte lijn gereedschap">
        <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
          <path d="M4 20 20 4" />
        </svg>
      </button>
      <button class="tool-button" data-tool="circle" aria-label="Cirkel gereedschap">
        <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="12" cy="12" r="7" />
          <circle cx="12" cy="12" r="2.2" />
        </svg>
      </button>
      <button class="tool-button" data-tool="polygon" aria-label="Veelhoek gereedschap">
        <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
          <path d="M6 4 3 9l3 5 6 6 6-3 3-5-3-5-6-3z" />
        </svg>
      </button>
      <button class="tool-button" data-tool="text" aria-label="Tekst gereedschap">
        <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
          <path d="M5 6h14" />
          <path d="M12 6v12" />
        </svg>
      </button>
      <span class="badge">Beta</span>
    </div>
  </header>
  <main class="layout">
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        Algebra
        <button class="tool-button" id="close-sidebar" aria-label="Sluit paneel">
          <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
            <path d="m7 7 10 10" />
            <path d="m17 7-10 10" />
          </svg>
        </button>
      </div>
      <div class="algebra-list" id="algebra-list" aria-live="polite"></div>
    </aside>
    <section class="graph-container">
      <div class="floating-controls">
        <div class="control-row">
          <button type="button" class="round-button" id="undo" aria-label="Ongedaan maken" disabled>
            <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
              <path d="M7 10H3V6" />
              <path d="M3 10c0 6 6 8 10 8 4.97 0 8-2.9 8-7a7 7 0 0 0-7-7c-2.7 0-5.2 1.1-6.8 3" />
            </svg>
          </button>
          <button type="button" class="round-button" id="redo" aria-label="Opnieuw uitvoeren" disabled>
            <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
              <path d="M17 10h4V6" />
              <path d="M21 10c0 6-6 8-10 8-4.97 0-8-2.9-8-7a7 7 0 0 1 7-7c2.7 0 5.2 1.1 6.8 3" />
            </svg>
          </button>
        </div>
        <button type="button" class="round-button" id="zoom-in" aria-label="Zoom in">
          <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="11" cy="11" r="7" />
            <path d="M11 8v6" />
            <path d="M8 11h6" />
            <path d="m20 20-3-3" />
          </svg>
        </button>
        <button type="button" class="round-button" id="zoom-out" aria-label="Zoom uit">
          <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="11" cy="11" r="7" />
            <path d="M8 11h6" />
            <path d="m20 20-3-3" />
          </svg>
        </button>
        <button type="button" class="round-button" id="reset-view" aria-label="Reset weergave">
          <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
            <path d="M3 12a9 9 0 1 0 3.1-6.9L3 8" />
            <path d="M3 3v5h5" />
          </svg>
        </button>
      </div>
      <canvas id="board" width="1600" height="1200" aria-label="Coördinaatvlak"></canvas>
      <div class="quick-actions" id="quick-actions" role="group" aria-label="Snelle functievoorbeelden"></div>
      <div class="command-bar">
        <span aria-hidden="true">+</span>
        <input type="text" id="command-input" class="command-input" placeholder="Voer een opdracht of functie in, bijv. y=x^2 of A=(2,1)" autocomplete="off" />
        <button class="command-button" id="toggle-keyboard" type="button" aria-label="Toon toetsenbord" aria-pressed="false">
          <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
            <rect x="3" y="5" width="18" height="14" rx="2" ry="2" />
            <path d="M7 9h0" />
            <path d="M11 9h0" />
            <path d="M15 9h0" />
            <path d="M7 13h0" />
            <path d="M11 13h0" />
            <path d="M15 13h0" />
          </svg>
        </button>
      </div>
      <div class="math-keyboard" id="math-keyboard" aria-hidden="true">
        <div class="keyboard-header">
          <div class="keyboard-handle" aria-hidden="true"></div>
          <div class="keyboard-tabs" role="tablist" aria-label="Toetsenbord categorieën"></div>
        </div>
        <div class="keyboard-rows" role="group" aria-live="polite"></div>
      </div>
    </section>
  </main>
  <script>
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const graphContainer = document.querySelector('.graph-container');
    const commandBar = document.querySelector('.command-bar');
    const sidebar = document.getElementById('sidebar');
    const toggleSidebarBtn = document.getElementById('toggle-sidebar');
    const closeSidebarBtn = document.getElementById('close-sidebar');
    const algebraList = document.getElementById('algebra-list');
    const commandInput = document.getElementById('command-input');
    const keyboardToggle = document.getElementById('toggle-keyboard');
    const keyboard = document.getElementById('math-keyboard');
    const keyboardTabs = keyboard.querySelector('.keyboard-tabs');
    const keyboardRows = keyboard.querySelector('.keyboard-rows');
    const keyboardHandle = keyboard.querySelector('.keyboard-handle');
    const quickActions = document.getElementById('quick-actions');
    const undoButton = document.getElementById('undo');
    const redoButton = document.getElementById('redo');
    const viewportMeta = document.querySelector('meta[name="viewport"]');
    const defaultViewportContent = viewportMeta ? viewportMeta.getAttribute('content') : '';

    const DPR = window.devicePixelRatio || 1;
    const coarsePointerMedia = window.matchMedia('(pointer: coarse)');
    let isCoarsePointer = coarsePointerMedia.matches;

    const state = {
      tool: 'move',
      scale: 80,
      origin: { x: canvas.clientWidth / 2, y: canvas.clientHeight / 2 },
      points: [],
      segments: [],
      lines: [],
      circles: [],
      polygons: [],
      texts: [],
      functions: [],
      functionColorIndex: 0,
      functionCounter: 0,
      draggingPoint: null,
      dragOffset: { x: 0, y: 0 },
      panning: false,
      panStart: { x: 0, y: 0 },
      panCandidate: null,
      tempPoints: [],
      pinch: null,
      dragHistoryArmed: false,
      highlightedFunctionId: null,
      pendingFunctionHighlight: null,
      editingFunctionId: null,
    };

    const COLORS = {
      point: '#1f6feb',
      line: '#2b4aa0',
      segment: '#2b4aa0',
      circle: '#c03fb5',
      polygon: '#009688',
      text: '#444',
      function: '#e36209'
    };

    const FUNCTION_COLORS = ['#d83b01', '#1f6feb', '#2da44e', '#8b3dd9', '#e36209'];

    function withAlpha(color, alpha) {
      if (!color) {
        return `rgba(51, 103, 214, ${alpha})`;
      }
      if (color.startsWith('#')) {
        let hex = color.slice(1);
        if (hex.length === 3) {
          hex = hex.split('').map(char => char + char).join('');
        }
        if (hex.length === 6) {
          const r = parseInt(hex.slice(0, 2), 16);
          const g = parseInt(hex.slice(2, 4), 16);
          const b = parseInt(hex.slice(4, 6), 16);
          return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
      }
      if (color.startsWith('rgb')) {
        const values = color
          .replace(/rgba?\(([^)]+)\)/, '$1')
          .split(',')
          .map(part => part.trim());
        const [r = '51', g = '103', b = '214'] = values;
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      }
      return `rgba(51, 103, 214, ${alpha})`;
    }
    const SUBSCRIPTS = ['₀','₁','₂','₃','₄','₅','₆','₇','₈','₉'];
    const activeTouches = new Map();
    const history = { past: [], future: [] };
    const HISTORY_LIMIT = 100;
    let suspendHistory = false;
    let restoringState = false;

    function toSubscript(number) {
      return String(number)
        .split('')
        .map(digit => SUBSCRIPTS[Number(digit)] || digit)
        .join('');
    }

    function nextFunctionLabel() {
      state.functionCounter += 1;
      return `f${toSubscript(state.functionCounter)}(x)`;
    }

    function serializeState() {
      return {
        origin: { x: state.origin.x, y: state.origin.y },
        scale: state.scale,
        functionColorIndex: state.functionColorIndex,
        functionCounter: state.functionCounter,
        pointCounter,
        points: state.points.map(point => ({
          id: point.id,
          name: point.name,
          position: { x: point.position.x, y: point.position.y }
        })),
        segments: state.segments.map(segment => ({ ...segment })),
        lines: state.lines.map(line => ({ ...line })),
        circles: state.circles.map(circle => ({ ...circle })),
        polygons: state.polygons.map(polygon => ({ id: polygon.id, points: [...polygon.points] })),
        texts: state.texts.map(label => ({
          id: label.id,
          content: label.content,
          position: { x: label.position.x, y: label.position.y }
        })),
        functions: state.functions.map(fn => ({
          id: fn.id,
          label: fn.label,
          algebraLabel: fn.algebraLabel,
          expression: fn.expression,
          source: fn.source,
          color: fn.color,
          displayName: fn.displayName,
          evaluationExpression: fn.evaluationExpression
        }))
      };
    }

    function recordHistory() {
      if (suspendHistory) return;
      const snapshot = serializeState();
      history.past.push(snapshot);
      if (history.past.length > HISTORY_LIMIT) {
        history.past.shift();
      }
      history.future.length = 0;
      updateUndoRedoButtons();
    }

    function rebuildAlgebraList() {
      if (!algebraList) return;
      clearHighlightedAlgebra();
      algebraList.innerHTML = '';
      for (const point of state.points) {
        registerAlgebraEntry(point.id, `${point.name} = (${formatNumber(point.position.x)}, ${formatNumber(point.position.y)})`, 'point');
      }
      for (const line of state.lines) {
        registerAlgebraEntry(line.id, `l: lijn(${pointName(line.p1)}, ${pointName(line.p2)})`, 'line');
      }
      for (const segment of state.segments) {
        registerAlgebraEntry(segment.id, `s: segment(${pointName(segment.p1)}, ${pointName(segment.p2)})`, 'segment');
      }
      for (const circle of state.circles) {
        registerAlgebraEntry(circle.id, `c: cirkel(${pointName(circle.center)}, ${pointName(circle.edge)})`, 'circle');
      }
      for (const polygon of state.polygons) {
        registerAlgebraEntry(polygon.id, `p: veelhoek(${polygon.points.map(pointName).join(', ')})`, 'polygon');
      }
      for (const text of state.texts) {
        registerAlgebraEntry(text.id, `tekst: "${text.content}"`, 'text');
      }
      for (const fn of state.functions) {
        registerAlgebraEntry(fn.id, `${fn.algebraLabel} = ${fn.expression}`, 'function', fn.color);
      }
    }

    function restoreState(snapshot) {
      if (!snapshot) return;
      suspendHistory = true;
      restoringState = true;
      state.points = snapshot.points.map(point => ({
        id: point.id,
        name: point.name,
        position: { x: point.position.x, y: point.position.y }
      }));
      state.segments = snapshot.segments.map(segment => ({ ...segment }));
      state.lines = snapshot.lines.map(line => ({ ...line }));
      state.circles = snapshot.circles.map(circle => ({ ...circle }));
      state.polygons = snapshot.polygons.map(polygon => ({ id: polygon.id, points: [...polygon.points] }));
      state.texts = snapshot.texts.map(text => ({
        id: text.id,
        content: text.content,
        position: { x: text.position.x, y: text.position.y }
      }));
      state.origin = { x: snapshot.origin.x, y: snapshot.origin.y };
      state.scale = snapshot.scale;
      state.functionCounter = snapshot.functionCounter;
      pointCounter = snapshot.pointCounter ?? pointCounter;
      state.functionColorIndex = 0;
      state.tempPoints = [];
      state.tempPolygon = null;
      state.draggingPoint = null;
      state.dragOffset = { x: 0, y: 0 };
      state.panStart = { x: 0, y: 0 };
      state.panning = false;
      state.panCandidate = null;
      state.pinch = null;
      state.dragHistoryArmed = false;
      state.highlightedFunctionId = null;
      state.pendingFunctionHighlight = null;
      state.editingFunctionId = null;
      algebraList.innerHTML = '';
      state.functions = [];
      const savedFunctions = snapshot.functions || [];
      for (const fn of savedFunctions) {
        registerFunction({
          algebraLabel: fn.algebraLabel,
          expression: fn.expression,
          source: fn.source,
          graphLabel: fn.label,
          evaluationExpression: fn.evaluationExpression
        }, { id: fn.id, color: fn.color, displayName: fn.displayName, skipHistory: true, skipDraw: true, skipColorAdvance: true, skipAlgebra: true });
      }
      rebuildAlgebraList();
      state.functionColorIndex = snapshot.functionColorIndex;
      restoringState = false;
      suspendHistory = false;
      draw();
    }

    function undo() {
      if (!history.past.length) return;
      const snapshot = history.past.pop();
      history.future.push(serializeState());
      restoreState(snapshot);
      updateUndoRedoButtons();
    }

    function redo() {
      if (!history.future.length) return;
      const snapshot = history.future.pop();
      history.past.push(serializeState());
      restoreState(snapshot);
      updateUndoRedoButtons();
    }

    function updateUndoRedoButtons() {
      if (undoButton) {
        undoButton.disabled = history.past.length === 0;
      }
      if (redoButton) {
        redoButton.disabled = history.future.length === 0;
      }
    }

    function focusCommandInput() {
      if (!commandInput) return;
      try {
        commandInput.focus({ preventScroll: true });
      } catch (error) {
        commandInput.focus();
      }
    }

    function updateInputMode() {
      if (!commandInput) return;
      if (isCoarsePointer) {
        commandInput.setAttribute('inputmode', 'none');
      } else {
        commandInput.setAttribute('inputmode', 'text');
      }
      updateKeyboardPresentation();
    }

    function handlePointerPreferenceChange(event) {
      isCoarsePointer = event.matches;
      updateInputMode();
      if (!isCoarsePointer) {
        document.body.classList.remove('keyboard-open');
        document.body.style.setProperty('--keyboard-offset', '0px');
      } else if (keyboardVisible) {
        setKeyboardVisibility(true);
      }
    }

    function updateKeyboardPresentation() {
      if (!keyboard) return;
      const floating = !isCoarsePointer;
      keyboard.classList.toggle('desktop-floating', floating);
      if (floating) {
        positionFloatingKeyboard();
      } else {
        resetFloatingKeyboardStyles();
      }
    }

    function enforceStandaloneViewport() {
      if (!viewportMeta) return;
      viewportMeta.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no');
    }

    function restoreViewport() {
      if (!viewportMeta) return;
      if (!defaultViewportContent) return;
      viewportMeta.setAttribute('content', defaultViewportContent);
    }

    const KEYBOARD_SETS = [
      {
        id: 'numeric',
        label: '123',
        rows: [
          [
            { text: '7' },
            { text: '8' },
            { text: '9' },
            { text: '/' },
            { text: '^' }
          ],
          [
            { text: '4' },
            { text: '5' },
            { text: '6' },
            { text: '*' },
            { text: '-' }
          ],
          [
            { text: '1' },
            { text: '2' },
            { text: '3' },
            { text: '+' },
            { text: ',' }
          ],
          [
            { text: '0', classes: 'wide' },
            { text: '.', classes: 'small' },
            { text: '(', classes: 'small' },
            { text: ')', classes: 'small' },
            { text: 'x', classes: 'small' },
            { text: 'y', classes: 'small' },
            { text: 'π', insert: 'PI' },
            { text: 'e', insert: 'E' }
          ]
        ]
      },
      {
        id: 'functions',
        label: 'f(x)',
        rows: [
          [
            { text: 'sin', insert: 'sin()', cursorOffset: -1 },
            { text: 'cos', insert: 'cos()', cursorOffset: -1 },
            { text: 'tan', insert: 'tan()', cursorOffset: -1 },
            { text: '√', insert: 'sqrt()', cursorOffset: -1 },
            { text: '^2', insert: '^2' }
          ],
          [
            { text: 'asin', insert: 'asin()', cursorOffset: -1 },
            { text: 'acos', insert: 'acos()', cursorOffset: -1 },
            { text: 'atan', insert: 'atan()', cursorOffset: -1 },
            { text: 'ln', insert: 'ln()', cursorOffset: -1 },
            { text: 'log10', insert: 'log10()', cursorOffset: -1 }
          ],
          [
            { text: 'sinh', insert: 'sinh()', cursorOffset: -1 },
            { text: 'cosh', insert: 'cosh()', cursorOffset: -1 },
            { text: 'tanh', insert: 'tanh()', cursorOffset: -1 },
            { text: 'log2', insert: 'log2()', cursorOffset: -1 },
            { text: 'abs', insert: 'abs()', cursorOffset: -1 }
          ],
          [
            { text: 'sec', insert: 'sec()', cursorOffset: -1 },
            { text: 'csc', insert: 'csc()', cursorOffset: -1 },
            { text: 'cot', insert: 'cot()', cursorOffset: -1 },
            { text: '|x|', insert: 'abs()', cursorOffset: -1 },
            { text: 'sgn', insert: 'sign()', cursorOffset: -1 }
          ]
        ]
      },
      {
        id: 'letters',
        label: 'ABC',
        rows: [
          [
            { text: 'a' },
            { text: 'b' },
            { text: 'c' },
            { text: 'd' },
            { text: 'e' },
            { text: 'f' },
            { text: 'g' }
          ],
          [
            { text: 'h' },
            { text: 'i' },
            { text: 'j' },
            { text: 'k' },
            { text: 'l' },
            { text: 'm' },
            { text: 'n' }
          ],
          [
            { text: 'o' },
            { text: 'p' },
            { text: 'q' },
            { text: 'r' },
            { text: 's' },
            { text: 't' },
            { text: 'u' }
          ],
          [
            { text: 'v' },
            { text: 'w' },
            { text: 'x' },
            { text: 'y' },
            { text: 'z' }
          ]
        ]
      },
      {
        id: 'symbols',
        label: '#&',
        rows: [
          [
            { text: '≤', insert: '<=' },
            { text: '≥', insert: '>=' },
            { text: '≠', insert: '!=' },
            { text: '~' },
            { text: '%' }
          ],
          [
            { text: '∞', insert: 'Infinity' },
            { text: '[', classes: 'small' },
            { text: ']', classes: 'small' },
            { text: '{', classes: 'small' },
            { text: '}', classes: 'small' }
          ],
          [
            { text: '|', classes: 'small' },
            { text: ':', classes: 'small' },
            { text: ';', classes: 'small' },
            { text: '<', classes: 'small' },
            { text: '>', classes: 'small' }
          ],
          [
            { text: '=', classes: 'small' },
            { text: '≈', classes: 'small' },
            { text: '±', insert: '+-', classes: 'small' },
            { text: '«', classes: 'small' },
            { text: '»', classes: 'small' }
          ]
        ]
      }
    ];

    const COMMON_BOTTOM_ROW = [
      { text: '←', action: 'left', classes: 'command small' },
      { text: '→', action: 'right', classes: 'command small' },
      { text: '⌫', action: 'backspace', classes: 'command wide' },
      { text: '↵', action: 'enter', classes: 'command wide' }
    ];

    const QUICK_FUNCTION_ACTIONS = [
      { label: 'y = x', value: 'y = x' },
      { label: 'y = x²', value: 'y = x²' },
      { label: 'y = sin(x)', value: 'y = sin(x)' },
      { label: 'y = |x|', value: 'y = |x|' }
    ];

    let keyboardVisible = false;
    let skipNextKeyboardToggleClick = false;
    let activeKeyboardSet = KEYBOARD_SETS[0].id;
    let keyboardBuilt = false;
    const keyboardPosition = { x: null, y: null };
    const keyboardDragState = { active: false, pointerId: null, offsetX: 0, offsetY: 0 };

    function resizeCanvas() {
      const { clientWidth, clientHeight } = canvas;
      canvas.width = clientWidth * DPR;
      canvas.height = clientHeight * DPR;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      draw();
    }

    function worldToScreen({ x, y }) {
      return {
        x: state.origin.x + x * state.scale,
        y: state.origin.y - y * state.scale
      };
    }

    function screenToWorld(x, y) {
      return {
        x: (x - state.origin.x) / state.scale,
        y: (state.origin.y - y) / state.scale
      };
    }

    function clampScale(value) {
      return Math.min(240, Math.max(6, value));
    }

    function getTickStep() {
      const pixelsPerUnit = state.scale;
      if (!Number.isFinite(pixelsPerUnit) || pixelsPerUnit <= 0) {
        return 1;
      }
      const targetPixels = 80;
      const rawStep = targetPixels / pixelsPerUnit;
      const power = Math.pow(10, Math.floor(Math.log10(rawStep)));
      const candidates = [1, 2, 5, 10];
      let step = power;
      for (const candidate of candidates) {
        if (rawStep <= candidate * power) {
          step = candidate * power;
          break;
        }
      }
      if (!Number.isFinite(step) || step <= 0) {
        step = 1;
      }
      return step;
    }

    function getGridSubdivisions(step) {
      if (!Number.isFinite(step) || step <= 0) {
        return 1;
      }
      const magnitude = Math.pow(10, Math.floor(Math.log10(step)));
      const normalized = step / magnitude;
      if (Math.abs(normalized - 1) < 1e-6) return 5;
      if (Math.abs(normalized - 2) < 1e-6) return 4;
      if (Math.abs(normalized - 5) < 1e-6) return 5;
      if (Math.abs(normalized - 10) < 1e-6) return 5;
      return 5;
    }

    function getPlotSampleStep() {
      const scale = state.scale;
      if (!Number.isFinite(scale) || scale <= 0) {
        return 1;
      }
      const target = 80 / scale;
      return Math.max(0.25, Math.min(4, target));
    }

    function formatAxisValue(value, step) {
      if (!Number.isFinite(value)) {
        return '';
      }
      const absStep = Math.abs(step) || 1;
      let decimals = 0;
      if (absStep < 1) {
        decimals = Math.ceil(-Math.log10(absStep)) + 2;
      }
      decimals = Math.min(6, Math.max(decimals, absStep < 0.25 ? 3 : 0));
      const factor = Math.pow(10, decimals);
      const normalized = Math.round(value * factor) / factor;
      let text = normalized.toFixed(decimals);
      text = text.replace(/\.0+$/, '').replace(/(\.\d*?)0+$/, '$1');
      if (text === '-0') {
        text = '0';
      }
      return text;
    }

    function drawGrid() {
      const bounds = {
        left: -state.origin.x / state.scale,
        right: (canvas.clientWidth - state.origin.x) / state.scale,
        bottom: -(canvas.clientHeight - state.origin.y) / state.scale,
        top: state.origin.y / state.scale
      };

      ctx.save();
      ctx.scale(DPR, DPR);
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      ctx.clearRect(0, 0, width, height);

      const tickStep = getTickStep();
      const subdivisions = getGridSubdivisions(tickStep);
      const minorStep = subdivisions > 0 ? tickStep / subdivisions : 0;
      const epsilon = tickStep * 1e-6;

      if (minorStep > 0 && Number.isFinite(minorStep)) {
        ctx.lineWidth = 1 / DPR;
        ctx.strokeStyle = '#eef1fa';
        ctx.beginPath();
        const startMinorX = Math.floor(bounds.left / minorStep) * minorStep;
        const endMinorX = Math.ceil(bounds.right / minorStep) * minorStep;
        for (let value = startMinorX; value <= endMinorX + minorStep * 0.5; value += minorStep) {
          const multiple = value / tickStep;
          if (Math.abs(value) <= epsilon) continue;
          if (Math.abs(multiple - Math.round(multiple)) < epsilon) continue;
          const screenX = Math.round(state.origin.x + value * state.scale) + 0.5;
          ctx.moveTo(screenX, 0);
          ctx.lineTo(screenX, height);
        }
        const startMinorY = Math.floor(bounds.bottom / minorStep) * minorStep;
        const endMinorY = Math.ceil(bounds.top / minorStep) * minorStep;
        for (let value = startMinorY; value <= endMinorY + minorStep * 0.5; value += minorStep) {
          const multiple = value / tickStep;
          if (Math.abs(value) <= epsilon) continue;
          if (Math.abs(multiple - Math.round(multiple)) < epsilon) continue;
          const screenY = Math.round(state.origin.y - value * state.scale) + 0.5;
          ctx.moveTo(0, screenY);
          ctx.lineTo(width, screenY);
        }
        ctx.stroke();
      }

      const majorWidth = Math.max(1.4, Math.min(2.6, state.scale / 60 + 1));
      ctx.lineWidth = majorWidth / DPR;
      ctx.strokeStyle = '#d5dae5';
      ctx.beginPath();
      const startMajorX = Math.ceil(bounds.left / tickStep) * tickStep;
      for (let value = startMajorX; value <= bounds.right + tickStep * 0.5; value += tickStep) {
        const screenX = Math.round(state.origin.x + value * state.scale) + 0.5;
        ctx.moveTo(screenX, 0);
        ctx.lineTo(screenX, height);
      }
      const startMajorY = Math.ceil(bounds.bottom / tickStep) * tickStep;
      for (let value = startMajorY; value <= bounds.top + tickStep * 0.5; value += tickStep) {
        const screenY = Math.round(state.origin.y - value * state.scale) + 0.5;
        ctx.moveTo(0, screenY);
        ctx.lineTo(width, screenY);
      }
      ctx.stroke();

      const xAxisY = Math.round(state.origin.y) + 0.5;
      const yAxisX = Math.round(state.origin.x) + 0.5;

      ctx.strokeStyle = '#9aa0a6';
      ctx.lineWidth = Math.max((majorWidth + 0.6) / DPR, 1.6 / DPR);
      ctx.beginPath();
      ctx.moveTo(0, xAxisY);
      ctx.lineTo(width, xAxisY);
      ctx.moveTo(yAxisX, 0);
      ctx.lineTo(yAxisX, height);
      ctx.stroke();

      ctx.lineWidth = 1 / DPR;
      ctx.strokeStyle = '#9aa0a6';
      ctx.fillStyle = '#5f6368';
      ctx.font = '12px Inter, "Segoe UI", sans-serif';

      const xAxisVisible = xAxisY >= 0 && xAxisY <= height;
      if (xAxisVisible) {
        const xStart = Math.ceil(bounds.left / tickStep) * tickStep;
        ctx.beginPath();
        for (let value = xStart; value <= bounds.right + tickStep * 0.5; value += tickStep) {
          const screenX = Math.round(state.origin.x + value * state.scale) + 0.5;
          ctx.moveTo(screenX, xAxisY - 4);
          ctx.lineTo(screenX, xAxisY + 4);
        }
        ctx.stroke();

        const baseline = xAxisY > height - 24 ? 'bottom' : 'top';
        ctx.textAlign = 'center';
        ctx.textBaseline = baseline;
        const offsetY = baseline === 'top' ? 6 : -6;
        for (let value = xStart; value <= bounds.right + tickStep * 0.5; value += tickStep) {
          if (Math.abs(value) < tickStep / 2) continue;
          const screenX = state.origin.x + value * state.scale;
          ctx.fillText(formatAxisValue(value, tickStep), screenX, xAxisY + offsetY);
        }
      }

      const yAxisVisible = yAxisX >= 0 && yAxisX <= width;
      if (yAxisVisible) {
        const yStart = Math.ceil(bounds.bottom / tickStep) * tickStep;
        ctx.beginPath();
        for (let value = yStart; value <= bounds.top + tickStep * 0.5; value += tickStep) {
          const screenY = Math.round(state.origin.y - value * state.scale) + 0.5;
          ctx.moveTo(yAxisX - 4, screenY);
          ctx.lineTo(yAxisX + 4, screenY);
        }
        ctx.stroke();

        const align = yAxisX > width - 48 ? 'right' : 'left';
        ctx.textAlign = align;
        ctx.textBaseline = 'middle';
        const offsetX = align === 'left' ? 6 : -6;
        for (let value = yStart; value <= bounds.top + tickStep * 0.5; value += tickStep) {
          if (Math.abs(value) < tickStep / 2) continue;
          const screenY = state.origin.y - value * state.scale;
          ctx.fillText(formatAxisValue(value, tickStep), yAxisX + offsetX, screenY);
        }
      }

      if (xAxisVisible && yAxisVisible) {
        const align = yAxisX > width - 48 ? 'right' : 'left';
        const baseline = xAxisY > height - 24 ? 'bottom' : 'top';
        ctx.textAlign = align;
        ctx.textBaseline = baseline;
        const offsetX = align === 'left' ? 6 : -6;
        const offsetY = baseline === 'top' ? 6 : -6;
        ctx.fillText('0', state.origin.x + offsetX, state.origin.y + offsetY);
      }

      ctx.restore();
    }

    function drawPoints() {
      ctx.save();
      ctx.scale(DPR, DPR);
      ctx.fillStyle = COLORS.point;
      for (const point of state.points) {
        const { x, y } = worldToScreen(point.position);
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = COLORS.point;
        ctx.font = '12px Inter, sans-serif';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText(point.name, x + 8, y + 6);
      }
      ctx.restore();
    }

    function drawLines() {
      ctx.save();
      ctx.scale(DPR, DPR);
      ctx.lineWidth = 2 / DPR;

      for (const line of state.lines) {
        ctx.strokeStyle = COLORS.line;
        const { p1, p2 } = line;
        const a = state.points.find(p => p.id === p1);
        const b = state.points.find(p => p.id === p2);
        if (!a || !b) continue;
        const A = worldToScreen(a.position);
        const B = worldToScreen(b.position);
        const dir = { x: B.x - A.x, y: B.y - A.y };
        const len = Math.hypot(dir.x, dir.y) || 1;
        const unit = { x: dir.x / len, y: dir.y / len };
        const large = 4000;
        ctx.beginPath();
        ctx.moveTo(A.x - unit.x * large, A.y - unit.y * large);
        ctx.lineTo(A.x + unit.x * large, A.y + unit.y * large);
        ctx.stroke();
      }

      for (const segment of state.segments) {
        ctx.strokeStyle = COLORS.segment;
        const { p1, p2 } = segment;
        const a = state.points.find(p => p.id === p1);
        const b = state.points.find(p => p.id === p2);
        if (!a || !b) continue;
        const A = worldToScreen(a.position);
        const B = worldToScreen(b.position);
        ctx.beginPath();
        ctx.moveTo(A.x, A.y);
        ctx.lineTo(B.x, B.y);
        ctx.stroke();
      }

      for (const polygon of state.polygons) {
        if (polygon.points.length < 3) continue;
        ctx.fillStyle = 'rgba(0,150,136,0.15)';
        ctx.strokeStyle = COLORS.polygon;
        ctx.beginPath();
        const start = state.points.find(p => p.id === polygon.points[0]);
        if (!start) continue;
        const first = worldToScreen(start.position);
        ctx.moveTo(first.x, first.y);
        for (let i = 1; i < polygon.points.length; i++) {
          const pt = state.points.find(p => p.id === polygon.points[i]);
          if (!pt) continue;
          const pos = worldToScreen(pt.position);
          ctx.lineTo(pos.x, pos.y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      }

      for (const circle of state.circles) {
        const center = state.points.find(p => p.id === circle.center);
        const edge = state.points.find(p => p.id === circle.edge);
        if (!center || !edge) continue;
        const C = worldToScreen(center.position);
        const radius = distance(center.position, edge.position) * state.scale;
        ctx.strokeStyle = COLORS.circle;
        ctx.beginPath();
        ctx.arc(C.x, C.y, radius, 0, Math.PI * 2);
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawFunctions() {
      if (!state.functions.length) return;
      ctx.save();
      ctx.scale(DPR, DPR);
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      const sampleStep = getPlotSampleStep();
      const steps = sampleStep > 0 ? Math.ceil(width / sampleStep) : width;
      const verticalThreshold = height * 4;
      const scale = state.scale;
      if (!Number.isFinite(scale) || scale <= 0) {
        ctx.restore();
        return;
      }
      const originX = state.origin.x;
      const originY = state.origin.y;
      const inverseScale = 1 / scale;
      for (const fn of state.functions) {
        const path = [];
        let pathStarted = false;
        let previousPoint = null;
        for (let index = 0; index <= steps; index++) {
          const sx = index === steps ? width : Math.min(index * sampleStep, width);
          const worldX = (sx - originX) * inverseScale;
          let value;
          try {
            value = fn.eval(worldX);
          } catch (err) {
            pathStarted = false;
            previousPoint = null;
            continue;
          }
          if (!Number.isFinite(value) || Math.abs(value) > 1e6) {
            pathStarted = false;
            previousPoint = null;
            continue;
          }
          const sy = originY - value * scale;
          if (!Number.isFinite(sy)) {
            pathStarted = false;
            previousPoint = null;
            continue;
          }
          const largeJump = previousPoint && Math.abs(sy - previousPoint.sy) > verticalThreshold;
          if (!pathStarted || largeJump) {
            path.push({ move: true, x: sx, y: sy });
            pathStarted = true;
          } else {
            path.push({ move: false, x: sx, y: sy });
          }
          previousPoint = { sx, sy };
        }

        if (!path.length) {
          continue;
        }

        if (state.highlightedFunctionId === fn.id) {
          ctx.save();
          ctx.lineWidth = 5 / DPR;
          ctx.strokeStyle = withAlpha(fn.color || COLORS.function, 0.35);
          ctx.beginPath();
          for (const point of path) {
            if (point.move) {
              ctx.moveTo(point.x, point.y);
            } else {
              ctx.lineTo(point.x, point.y);
            }
          }
          ctx.stroke();
          ctx.restore();
        }

        ctx.lineWidth = 2 / DPR;
        ctx.strokeStyle = fn.color || COLORS.function;
        ctx.beginPath();
        for (const point of path) {
          if (point.move) {
            ctx.moveTo(point.x, point.y);
          } else {
            ctx.lineTo(point.x, point.y);
          }
        }
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawTexts() {
      if (!state.texts.length) return;
      ctx.save();
      ctx.scale(DPR, DPR);
      ctx.fillStyle = COLORS.text;
      ctx.font = '14px Inter, sans-serif';
      for (const label of state.texts) {
        const { x, y } = worldToScreen(label.position);
        ctx.fillText(label.content, x, y);
      }
      ctx.restore();
    }

    function drawPolygonPreview() {
      if (!state.tempPolygon || state.tempPolygon.points.length === 0) return;
      ctx.save();
      ctx.scale(DPR, DPR);
      ctx.setLineDash([6, 6]);
      ctx.lineWidth = 2 / DPR;
      ctx.strokeStyle = COLORS.polygon;

      const vertices = state.tempPolygon.points
        .map(id => state.points.find(p => p.id === id))
        .filter(Boolean);
      if (vertices.length === 0) {
        ctx.restore();
        return;
      }

      ctx.beginPath();
      const first = worldToScreen(vertices[0].position);
      ctx.moveTo(first.x, first.y);
      for (let i = 1; i < vertices.length; i++) {
        const pos = worldToScreen(vertices[i].position);
        ctx.lineTo(pos.x, pos.y);
      }
      if (state.tempPolygon.preview) {
        const preview = worldToScreen(state.tempPolygon.preview);
        ctx.lineTo(preview.x, preview.y);
      }
      ctx.stroke();
      ctx.restore();
    }

    function draw() {
      drawGrid();
      drawLines();
      drawPolygonPreview();
      drawFunctions();
      drawPoints();
      drawTexts();
    }

    function clearHighlightedAlgebra() {
      if (!algebraList) return;
      algebraList.querySelectorAll('.algebra-item.selected').forEach(item => {
        item.classList.remove('selected');
        item.style.removeProperty('--highlight-outline');
        item.style.removeProperty('--highlight-glow');
      });
    }

    function setHighlightedFunction(id, options = {}) {
      const { scroll = true, force = false } = options;
      if (state.highlightedFunctionId === id && !force) {
        if (scroll && id && algebraList) {
          const current = algebraList.querySelector(`[data-id="${id}"]`);
          if (current) {
            current.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
          }
        }
        return;
      }
      clearHighlightedAlgebra();
      state.highlightedFunctionId = id;
      if (id && algebraList) {
        const item = algebraList.querySelector(`[data-id="${id}"]`);
        const fn = state.functions.find(entry => entry.id === id);
        if (item && fn) {
          item.style.setProperty('--highlight-outline', withAlpha(fn.color || COLORS.function, 0.5));
          item.style.setProperty('--highlight-glow', withAlpha(fn.color || COLORS.function, 0.35));
          item.classList.add('selected');
          if (scroll) {
            item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
          }
        }
      }
      draw();
    }

    function setTool(tool) {
      if (state.tool === 'polygon' && tool !== 'polygon') {
        cancelTempPolygon();
      }
      state.tool = tool;
      document.querySelectorAll('.tool-button[data-tool]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.tool === tool);
      });
      state.tempPoints = [];
      if (tool !== 'polygon') {
        state.tempPolygon = null;
      }
      draw();
    }

    function ensureMoveTool() {
      if (state.tool !== 'move') {
        setTool('move');
      }
    }

    function cancelTempPolygon() {
      if (!state.tempPolygon) return;
      const created = state.tempPolygon.createdPoints || [];
      for (const pointId of created) {
        removeObject(pointId, 'point', { silent: true, skipHistory: true });
      }
      state.tempPolygon = null;
    }

    function distance(a, b) {
      return Math.hypot(a.x - b.x, a.y - b.y);
    }

    function findPointNear(world, threshold = 0.25) {
      let closest = null;
      let min = Infinity;
      for (const point of state.points) {
        const dist = distance(point.position, world);
        if (dist < threshold && dist < min) {
          min = dist;
          closest = point;
        }
      }
      return closest;
    }

    function findFunctionNearScreen(x, y) {
      if (!state.functions.length) {
        return null;
      }
      if (!Number.isFinite(state.scale) || state.scale <= 0) {
        return null;
      }
      const tolerance = Math.max(10, Math.min(22, state.scale * 0.35));
      const worldX = (x - state.origin.x) / state.scale;
      const stepWorld = tolerance / state.scale;
      const offsets = [0, stepWorld, -stepWorld, 2 * stepWorld, -2 * stepWorld];
      let closest = null;
      let closestDistance = tolerance;
      for (const fn of state.functions) {
        for (const offset of offsets) {
          let value;
          try {
            value = fn.eval(worldX + offset);
          } catch (error) {
            continue;
          }
          if (!Number.isFinite(value) || Math.abs(value) > 1e6) {
            continue;
          }
          const screenX = state.origin.x + (worldX + offset) * state.scale;
          const screenY = state.origin.y - value * state.scale;
          const distancePx = Math.hypot(screenX - x, screenY - y);
          if (distancePx < closestDistance) {
            closestDistance = distancePx;
            closest = fn;
          }
        }
      }
      return closestDistance <= tolerance ? closest : null;
    }

    function snapWorldToGrid(world) {
      const position = { x: world.x, y: world.y };
      if (!Number.isFinite(state.scale) || state.scale <= 0) {
        return position;
      }
      const snapped = {
        x: Math.round(position.x),
        y: Math.round(position.y)
      };
      const originalScreen = worldToScreen(position);
      const snappedScreen = worldToScreen(snapped);
      const distancePx = Math.hypot(originalScreen.x - snappedScreen.x, originalScreen.y - snappedScreen.y);
      const thresholdPx = Math.max(6, Math.min(18, state.scale * 0.25));
      if (distancePx <= thresholdPx) {
        return snapped;
      }
      return position;
    }

    let pointCounter = 0;
    function nextPointName() {
      const code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      let index = pointCounter++;
      let name = '';
      do {
        name = code[index % code.length] + name;
        index = Math.floor(index / code.length) - 1;
      } while (index >= 0);
      return name;
    }

    function createPoint(world, existingName, options = {}) {
      const { snap = true, skipHistory = false } = options;
      if (!skipHistory) {
        recordHistory();
      }
      const name = existingName || nextPointName();
      const shouldSnap = snap;
      const position = shouldSnap ? snapWorldToGrid(world) : { x: world.x, y: world.y };
      const point = {
        id: crypto.randomUUID(),
        name,
        position
      };
      state.points.push(point);
      registerAlgebraEntry(point.id, `${name} = (${formatNumber(point.position.x)}, ${formatNumber(point.position.y)})`, 'point');
      draw();
      return point;
    }

    function registerAlgebraEntry(id, text, type, color) {
      const [title, ...rest] = text.split('=');
      const strongText = title.trim();
      const detailText = rest.join('=').trim();
      let item = algebraList.querySelector(`[data-id="${id}"]`);
      if (!item) {
        item = document.createElement('div');
        item.className = 'algebra-item';
        item.dataset.id = id;
        item.dataset.type = type;

        const icon = document.createElement('span');
        icon.className = 'algebra-color';
        item.appendChild(icon);

        const label = document.createElement('div');
        label.className = 'algebra-label';
        const strong = document.createElement('strong');
        const span = document.createElement('span');
        span.className = 'algebra-detail';
        label.appendChild(strong);
        label.appendChild(span);
        item.appendChild(label);

        const removeButton = document.createElement('button');
        removeButton.type = 'button';
        removeButton.className = 'delete-button';
        removeButton.setAttribute('aria-label', 'Verwijder object');
        removeButton.innerHTML = `
          <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
            <path d="M6 6 18 18" />
            <path d="M6 18 18 6" />
          </svg>
        `;
        item.appendChild(removeButton);

        algebraList.appendChild(item);
      }

      item.dataset.type = type;
      const iconEl = item.querySelector('.algebra-color');
      if (iconEl) {
        iconEl.style.background = color || COLORS[type] || '#888';
      }
      const strongEl = item.querySelector('.algebra-label strong');
      if (strongEl) {
        strongEl.textContent = strongText;
      }
      const detailEl = item.querySelector('.algebra-detail');
      if (detailEl) {
        detailEl.textContent = detailText ? `= ${detailText}` : '';
      }

      const behavior = restoringState ? 'auto' : 'smooth';
      algebraList.scrollTo({ top: algebraList.scrollHeight, behavior });
    }

    function removeAlgebraEntry(id) {
      const item = algebraList.querySelector(`[data-id="${id}"]`);
      if (item) {
        item.remove();
      }
    }

    function buildQuickActions() {
      if (!quickActions) return;
      quickActions.innerHTML = '';
      for (const action of QUICK_FUNCTION_ACTIONS) {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'quick-action';
        button.textContent = action.label;
        button.dataset.value = action.value;
        quickActions.appendChild(button);
      }
    }

    function applyQuickAction(value) {
      if (!value) return;
      commandInput.value = value;
      const position = value.length;
      commandInput.setSelectionRange(position, position);
      focusCommandInput();
      if (window.innerWidth < 920 && !keyboardVisible) {
        setKeyboardVisibility(true);
      }
    }

    function ensureKeyboardBuilt() {
      if (keyboardBuilt) return;
      keyboardBuilt = true;
      keyboardTabs.innerHTML = '';
      for (const set of KEYBOARD_SETS) {
        const tab = document.createElement('button');
        tab.type = 'button';
        tab.className = 'keyboard-tab';
        tab.dataset.set = set.id;
        tab.textContent = set.label;
        tab.addEventListener('click', () => {
          ensureMoveTool();
          setActiveKeyboardSet(set.id);
        });
        keyboardTabs.appendChild(tab);
      }
      setActiveKeyboardSet(activeKeyboardSet);
    }

    function setActiveKeyboardSet(id) {
      activeKeyboardSet = id;
      keyboardTabs.querySelectorAll('.keyboard-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.set === id);
      });
      renderKeyboardRows(id);
    }

    function createKeyboardRow(keys) {
      const rowElement = document.createElement('div');
      rowElement.className = 'keyboard-row';
      for (const key of keys) {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = `keyboard-key${key.classes ? ` ${key.classes}` : ''}`;
        button.textContent = key.text;
        button.addEventListener('pointerdown', event => {
          event.preventDefault();
          ensureMoveTool();
          handleKeyboardKey(key);
        });
        button.addEventListener('click', event => event.preventDefault());
        rowElement.appendChild(button);
      }
      return rowElement;
    }

    function renderKeyboardRows(id) {
      const set = KEYBOARD_SETS.find(entry => entry.id === id);
      if (!set) return;
      keyboardRows.innerHTML = '';
      for (const row of set.rows) {
        keyboardRows.appendChild(createKeyboardRow(row));
      }
      keyboardRows.appendChild(createKeyboardRow(COMMON_BOTTOM_ROW));
    }

    function handleKeyboardKey(key) {
      focusCommandInput();
      ensureMoveTool();
      if (key.action === 'backspace') {
        deleteAtCursor();
        return;
      }
      if (key.action === 'enter') {
        submitCommandFromKeyboard();
        return;
      }
      if (key.action === 'left') {
        moveCursor(-1);
        return;
      }
      if (key.action === 'right') {
        moveCursor(1);
        return;
      }
      const insertion = key.insert ?? key.text;
      const offset = key.cursorOffset ?? 0;
      insertAtCursor(insertion, offset);
    }

    function insertAtCursor(text, cursorOffset = 0) {
      const start = commandInput.selectionStart ?? commandInput.value.length;
      const end = commandInput.selectionEnd ?? commandInput.value.length;
      const before = commandInput.value.slice(0, start);
      const after = commandInput.value.slice(end);
      commandInput.value = before + text + after;
      const position = start + text.length + cursorOffset;
      commandInput.setSelectionRange(position, position);
    }

    function deleteAtCursor() {
      const start = commandInput.selectionStart ?? commandInput.value.length;
      const end = commandInput.selectionEnd ?? commandInput.value.length;
      if (start !== end) {
        const before = commandInput.value.slice(0, start);
        const after = commandInput.value.slice(end);
        commandInput.value = before + after;
        commandInput.setSelectionRange(start, start);
        return;
      }
      if (start === 0) return;
      const before = commandInput.value.slice(0, start - 1);
      const after = commandInput.value.slice(end);
      commandInput.value = before + after;
      commandInput.setSelectionRange(start - 1, start - 1);
    }

    function moveCursor(delta) {
      const length = commandInput.value.length;
      let position = (commandInput.selectionStart ?? length) + delta;
      position = Math.max(0, Math.min(length, position));
      commandInput.setSelectionRange(position, position);
    }

    function submitCommandFromKeyboard() {
      if (!commandInput.value.trim()) return;
      parseCommand(commandInput.value);
      commandInput.value = '';
    }

    function resetFloatingKeyboardStyles() {
      if (!keyboard) return;
      keyboardPosition.x = null;
      keyboardPosition.y = null;
      keyboard.style.removeProperty('left');
      keyboard.style.removeProperty('top');
      keyboard.style.removeProperty('right');
      keyboard.style.removeProperty('bottom');
    }

    function moveKeyboardTo(x, y) {
      if (!keyboard) return;
      const rect = keyboard.getBoundingClientRect();
      const width = rect.width || keyboard.offsetWidth || 0;
      const height = rect.height || keyboard.offsetHeight || 0;
      if (!width || !height) {
        keyboardPosition.x = x;
        keyboardPosition.y = y;
        return;
      }
      const margin = 16;
      const minX = margin;
      const minY = margin;
      const maxX = Math.max(minX, window.innerWidth - width - margin);
      const maxY = Math.max(minY, window.innerHeight - height - margin);
      const clampedX = Math.min(Math.max(minX, x), maxX);
      const clampedY = Math.min(Math.max(minY, y), maxY);
      keyboard.style.left = `${clampedX}px`;
      keyboard.style.top = `${clampedY}px`;
      keyboard.style.right = 'auto';
      keyboard.style.bottom = 'auto';
      keyboardPosition.x = clampedX;
      keyboardPosition.y = clampedY;
    }

    function positionFloatingKeyboard() {
      if (!keyboard || isCoarsePointer || !keyboard.classList.contains('desktop-floating')) {
        return;
      }
      if (!keyboardVisible) {
        return;
      }
      requestAnimationFrame(() => {
        const rect = keyboard.getBoundingClientRect();
        const width = rect.width || keyboard.offsetWidth || 0;
        const height = rect.height || keyboard.offsetHeight || 0;
        if (!width || !height) {
          return;
        }
        const margin = 16;
        let x = keyboardPosition.x;
        let y = keyboardPosition.y;
        if (!Number.isFinite(x)) {
          x = window.innerWidth - width - margin;
        }
        if (!Number.isFinite(y)) {
          y = window.innerHeight - height - margin;
        }
        moveKeyboardTo(x, y);
      });
    }

    function startKeyboardDrag(event) {
      if (isCoarsePointer) return;
      if (!keyboard || !keyboard.classList.contains('desktop-floating')) return;
      if (event.button !== 0 && event.pointerType === 'mouse') return;
      ensureMoveTool();
      keyboardDragState.active = true;
      keyboardDragState.pointerId = event.pointerId;
      const rect = keyboard.getBoundingClientRect();
      keyboardDragState.offsetX = event.clientX - rect.left;
      keyboardDragState.offsetY = event.clientY - rect.top;
      try {
        keyboard.setPointerCapture(event.pointerId);
      } catch (error) {
        /* noop */
      }
      keyboard.classList.add('dragging');
      event.preventDefault();
    }

    function updateKeyboardDrag(event) {
      if (!keyboardDragState.active || event.pointerId !== keyboardDragState.pointerId) return;
      event.preventDefault();
      const x = event.clientX - keyboardDragState.offsetX;
      const y = event.clientY - keyboardDragState.offsetY;
      moveKeyboardTo(x, y);
    }

    function endKeyboardDrag(event) {
      if (!keyboardDragState.active || event.pointerId !== keyboardDragState.pointerId) return;
      keyboardDragState.active = false;
      keyboardDragState.pointerId = null;
      keyboard.classList.remove('dragging');
      try {
        keyboard.releasePointerCapture(event.pointerId);
      } catch (error) {
        /* noop */
      }
      positionFloatingKeyboard();
    }

    function setKeyboardVisibility(visible) {
      if (visible) {
        ensureKeyboardBuilt();
      }
      keyboardVisible = visible;
      if (visible) {
        ensureMoveTool();
      }
      keyboard.classList.toggle('active', visible);
      keyboard.setAttribute('aria-hidden', String(!visible));
      keyboardToggle.classList.toggle('active', visible);
      keyboardToggle.setAttribute('aria-label', visible ? 'Verberg toetsenbord' : 'Toon toetsenbord');
      keyboardToggle.setAttribute('aria-pressed', String(visible));
      if (visible) {
        focusCommandInput();
      }
      if (!isCoarsePointer && visible) {
        positionFloatingKeyboard();
      }
      if (isCoarsePointer) {
        document.body.classList.toggle('keyboard-open', visible);
        if (visible) {
          requestAnimationFrame(() => {
            const height = keyboard.offsetHeight || 0;
            document.body.style.setProperty('--keyboard-offset', `${height}px`);
          });
        } else {
          document.body.style.setProperty('--keyboard-offset', '0px');
        }
      }
      requestAnimationFrame(resizeCanvas);
    }

    function prepareExpression(expression) {
      if (!expression) return '';
      const superscripts = {
        '⁰': '^0',
        '¹': '^1',
        '²': '^2',
        '³': '^3',
        '⁴': '^4',
        '⁵': '^5',
        '⁶': '^6',
        '⁷': '^7',
        '⁸': '^8',
        '⁹': '^9'
      };
      let normalized = expression.replace(/[⁰¹²³⁴⁵⁶⁷⁸⁹]/g, char => superscripts[char] || char);
      normalized = normalized
        .replace(/\s+/g, '')
        .replace(/[,;]/g, '.')
        .replace(/√/g, 'sqrt')
        .replace(/π/gi, 'PI')
        .replace(/\bpi\b/gi, 'PI')
        .replace(/τ/gi, '(2*PI)')
        .replace(/\btau\b/gi, '(2*PI)')
        .replace(/[·×]/g, '*')
        .replace(/[–—]/g, '-')
        .replace(/÷/g, '/')
        .replace(/\bsgn\b/gi, 'sign')
        .replace(/\bctg\b/gi, 'cot')
        .replace(/\|([^|]+)\|/g, 'abs($1)');
      const lowerFunctions = ['sin','cos','tan','cot','sec','csc','asin','acos','atan','atan2','sinh','cosh','tanh','asinh','acosh','atanh','log','ln','abs','sqrt','floor','ceil','round','exp','sign','sgn','log10','log2','min','max','pow','hypot'];
      for (const name of lowerFunctions) {
        const regex = new RegExp(name, 'gi');
        normalized = normalized.replace(regex, name);
      }
      const implicitFunctions = [...new Set(lowerFunctions)].sort((a, b) => b.length - a.length);
      for (const name of implicitFunctions) {
        const pattern = new RegExp(`([0-9xy)])(${name})`, 'gi');
        normalized = normalized.replace(pattern, (_match, left, fnName) => `${left}*${fnName}`);
      }
      normalized = normalized
        .replace(/\^/g, '**')
        .replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|sinh|cosh|tanh|asinh|acosh|atanh|ln|log|exp)\*\*([0-9]+)\(([^()]+)\)/g, (_match, fn, power, inner) => `pow(${fn}(${inner}),${power})`)
        .replace(/--/g, '+')
        .replace(/\+\+/g, '+')
        .replace(/\+-/g, '-')
        .replace(/-\+/g, '-')
        .replace(/\be\b/gi, 'E');
      normalized = normalized
        .replace(/([0-9])([xy])/gi, '$1*$2')
        .replace(/([xy])([0-9])/gi, '$1*$2')
        .replace(/([xy])([xy])/gi, '$1*$2')
        .replace(/([xy])\(/gi, '$1*(')
        .replace(/\)([xy])/gi, ')*$1')
        .replace(/([0-9])\(/g, '$1*(')
        .replace(/\)([0-9])/g, ')*$1')
        .replace(/\)\(/g, ')*(');
      normalized = normalized
        .replace(/([0-9xy)])PI/gi, '$1*PI')
        .replace(/PI([A-Za-z0-9(])/g, 'PI*$1')
        .replace(/([0-9xy)])E(?![+-]?\d)/gi, '$1*E')
        .replace(/E([xy(])/gi, 'E*$1');
      if (normalized.includes('|')) {
        throw new Error('Ongebalanceerde absolute waarde.');
      }
      return normalized;
    }

    function registerFunction({ algebraLabel, expression, source, graphLabel, evaluationExpression }, options = {}) {
      const {
        id,
        color: providedColor,
        displayName,
        skipHistory = false,
        skipDraw = false,
        skipColorAdvance = false,
        skipAlgebra = false
      } = options;
      const color = providedColor ?? FUNCTION_COLORS[state.functionColorIndex % FUNCTION_COLORS.length];
      try {
        const prepared = prepareExpression(evaluationExpression || expression);
        const compiled = new Function(
          'x',
          `const ln = Math.log;
           const log = Math.log10 ? Math.log10 : (v => Math.log(v) / Math.LN10);
           const log10 = Math.log10 ? Math.log10 : (v => Math.log(v) / Math.LN10);
           const log2 = Math.log2 ? Math.log2 : (v => Math.log(v) / Math.LN2);
           const sign = Math.sign;
           const sgn = Math.sign;
           const abs = Math.abs;
           const sec = x => 1 / Math.cos(x);
           const csc = x => 1 / Math.sin(x);
           const cot = x => 1 / Math.tan(x);
           const sech = x => 1 / Math.cosh(x);
           const csch = x => 1 / Math.sinh(x);
           const coth = x => 1 / Math.tanh(x);
           const tau = Math.PI * 2;
           with (Math) { return ${prepared}; }`
        );
        if (!skipHistory) {
          recordHistory();
        }
        const fn = {
          id: id || crypto.randomUUID(),
          label: graphLabel,
          algebraLabel,
          expression,
          source,
          eval: compiled,
          color,
          displayName: displayName || `${graphLabel} = ${expression}`,
          evaluationExpression: evaluationExpression || expression
        };
        state.functions.push(fn);
        if (!skipColorAdvance) {
          state.functionColorIndex = (state.functionColorIndex + 1) % FUNCTION_COLORS.length;
        }
        if (!skipAlgebra) {
          registerAlgebraEntry(fn.id, `${algebraLabel} = ${expression}`, 'function', color);
        }
        if (!skipDraw) {
          draw();
        }
        return fn;
      } catch (error) {
        console.error(error);
        alert('Kon functie niet interpreteren. Controleer de invoer.');
        return null;
      }
    }

    function updatePointAlgebra(point) {
      const item = algebraList.querySelector(`[data-id="${point.id}"]`);
      if (item) {
        const strong = item.querySelector('.algebra-label strong');
        if (strong) {
          strong.textContent = point.name;
        }
        const span = item.querySelector('.algebra-detail');
        if (span) {
          span.textContent = `= (${formatNumber(point.position.x)}, ${formatNumber(point.position.y)})`;
        }
      }
    }

    function formatNumber(value) {
      return Math.round(value * 1000) / 1000;
    }

    function startPinch() {
      if (activeTouches.size < 2) {
        state.pinch = null;
        return;
      }
      const touches = Array.from(activeTouches.values());
      const [first, second] = touches;
      const rect = canvas.getBoundingClientRect();
      const center = {
        x: (first.x + second.x) / 2 - rect.left,
        y: (first.y + second.y) / 2 - rect.top
      };
      state.pinch = {
        initialDistance: Math.hypot(first.x - second.x, first.y - second.y) || 1,
        initialScale: state.scale,
        center
      };
      state.draggingPoint = null;
      state.panning = false;
    }

    function updatePinch() {
      if (!state.pinch || activeTouches.size < 2) {
        return;
      }
      const touches = Array.from(activeTouches.values());
      const [first, second] = touches;
      const rect = canvas.getBoundingClientRect();
      const center = {
        x: (first.x + second.x) / 2 - rect.left,
        y: (first.y + second.y) / 2 - rect.top
      };
      const worldCenter = screenToWorld(center.x, center.y);
      const distance = Math.hypot(first.x - second.x, first.y - second.y) || state.pinch.initialDistance;
      const scaleFactor = distance / state.pinch.initialDistance;
      const nextScale = clampScale(state.pinch.initialScale * scaleFactor);
      state.scale = nextScale;
      const after = worldToScreen(worldCenter);
      state.origin.x += center.x - after.x;
      state.origin.y += center.y - after.y;
      state.pinch.initialDistance = distance;
      state.pinch.initialScale = state.scale;
      state.pinch.center = center;
      draw();
    }

    function removeObject(id, type, options = {}) {
      const { silent = false, skipHistory = false } = options;
      if (!id || !type) return;

      switch (type) {
        case 'point': {
          const index = state.points.findIndex(point => point.id === id);
          if (index === -1) break;
          if (!skipHistory) {
            recordHistory();
          }
          state.points.splice(index, 1);
          const relatedSegments = state.segments.filter(segment => segment.p1 === id || segment.p2 === id);
          relatedSegments.forEach(segment => removeObject(segment.id, 'segment', { silent: true, skipHistory: true }));
          const relatedLines = state.lines.filter(line => line.p1 === id || line.p2 === id);
          relatedLines.forEach(line => removeObject(line.id, 'line', { silent: true, skipHistory: true }));
          const relatedCircles = state.circles.filter(circle => circle.center === id || circle.edge === id);
          relatedCircles.forEach(circle => removeObject(circle.id, 'circle', { silent: true, skipHistory: true }));
          const relatedPolygons = state.polygons.filter(polygon => polygon.points.includes(id));
          relatedPolygons.forEach(polygon => removeObject(polygon.id, 'polygon', { silent: true, skipHistory: true }));
          if (state.draggingPoint && state.draggingPoint.id === id) {
            state.draggingPoint = null;
          }
          state.tempPoints = state.tempPoints.filter(pointId => pointId !== id);
          if (state.tempPolygon) {
            state.tempPolygon.points = state.tempPolygon.points.filter(pointId => pointId !== id);
            if (state.tempPolygon.points.length < 2) {
              state.tempPolygon = null;
            }
          }
          break;
        }
        case 'segment': {
          const index = state.segments.findIndex(segment => segment.id === id);
          if (index === -1) break;
          if (!skipHistory) {
            recordHistory();
          }
          state.segments.splice(index, 1);
          break;
        }
        case 'line': {
          const index = state.lines.findIndex(line => line.id === id);
          if (index === -1) break;
          if (!skipHistory) {
            recordHistory();
          }
          state.lines.splice(index, 1);
          break;
        }
        case 'circle': {
          const index = state.circles.findIndex(circle => circle.id === id);
          if (index === -1) break;
          if (!skipHistory) {
            recordHistory();
          }
          state.circles.splice(index, 1);
          break;
        }
        case 'polygon': {
          const index = state.polygons.findIndex(polygon => polygon.id === id);
          if (index === -1) break;
          if (!skipHistory) {
            recordHistory();
          }
          state.polygons.splice(index, 1);
          break;
        }
        case 'text': {
          const index = state.texts.findIndex(text => text.id === id);
          if (index === -1) break;
          if (!skipHistory) {
            recordHistory();
          }
          state.texts.splice(index, 1);
          break;
        }
        case 'function': {
          const index = state.functions.findIndex(fn => fn.id === id);
          if (index === -1) break;
          if (!skipHistory) {
            recordHistory();
          }
          state.functions.splice(index, 1);
          if (state.highlightedFunctionId === id) {
            setHighlightedFunction(null);
          }
          if (state.editingFunctionId === id) {
            state.editingFunctionId = null;
          }
          break;
        }
        default:
          break;
      }

      removeAlgebraEntry(id);
      if (!silent) {
        draw();
      }
    }

    function handlePointerDown(event) {
      if (event.pointerType === 'touch') {
        activeTouches.set(event.pointerId, { x: event.clientX, y: event.clientY });
        if (activeTouches.size === 2) {
          startPinch();
          event.preventDefault();
          return;
        }
        if (!event.isPrimary) {
          event.preventDefault();
          return;
        }
      }

      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const world = screenToWorld(x, y);

      if (state.pinch) {
        event.preventDefault();
        return;
      }

      if (state.tool !== 'move') {
        state.pendingFunctionHighlight = null;
        state.panCandidate = null;
      }

      if (state.tool === 'move') {
        const point = findPointNear(world, 0.3);
        if (point) {
          state.pendingFunctionHighlight = null;
          state.panCandidate = null;
          state.draggingPoint = point;
          const screenPos = worldToScreen(point.position);
          state.dragOffset = { x: screenPos.x - x, y: screenPos.y - y };
          state.dragHistoryArmed = true;
        } else {
          const nearbyFunction = findFunctionNearScreen(x, y);
          if (nearbyFunction) {
            state.pendingFunctionHighlight = { id: nearbyFunction.id };
            state.panning = false;
            state.panCandidate = { x, y };
            state.panStart = { x, y };
          } else {
            state.pendingFunctionHighlight = null;
            state.panning = true;
            state.panCandidate = null;
            state.panStart = { x, y };
            if (state.highlightedFunctionId) {
              setHighlightedFunction(null);
            }
          }
        }
      } else if (state.tool === 'point') {
        createPoint(world);
      } else if (state.tool === 'line' || state.tool === 'segment' || state.tool === 'circle') {
        handleConstructionTool(world);
      } else if (state.tool === 'polygon') {
        handlePolygonTool(world);
      } else if (state.tool === 'text') {
        handleTextTool(world);
      }

      event.preventDefault();
    }

    function handlePointerMove(event) {
      if (event.pointerType === 'touch') {
        if (activeTouches.has(event.pointerId)) {
          activeTouches.set(event.pointerId, { x: event.clientX, y: event.clientY });
        }
        if (state.pinch && activeTouches.size >= 2) {
          updatePinch();
          event.preventDefault();
          return;
        }
        if (!event.isPrimary) {
          event.preventDefault();
          return;
        }
      }

      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const world = screenToWorld(x, y);

      if (!state.panning && state.panCandidate) {
        const dx = x - state.panCandidate.x;
        const dy = y - state.panCandidate.y;
        if (Math.hypot(dx, dy) > 6) {
          const start = state.panCandidate;
          state.panning = true;
          state.panStart = { x: start.x, y: start.y };
          state.panCandidate = null;
          state.pendingFunctionHighlight = null;
        }
      }

      if (state.draggingPoint) {
        if (state.dragHistoryArmed) {
          recordHistory();
          state.dragHistoryArmed = false;
        }
        const position = screenToWorld(x + state.dragOffset.x, y + state.dragOffset.y);
        state.draggingPoint.position = snapWorldToGrid(position);
        updatePointAlgebra(state.draggingPoint);
        draw();
      } else if (state.panning) {
        const dx = x - state.panStart.x;
        const dy = y - state.panStart.y;
        state.origin.x += dx;
        state.origin.y += dy;
        state.panStart = { x, y };
        draw();
      }

      if (state.tool === 'polygon' && state.tempPolygon) {
        state.tempPolygon.preview = snapWorldToGrid(world);
        draw();
      }
    }

    function handlePointerUp(event) {
      if (event && event.pointerType === 'touch') {
        activeTouches.delete(event.pointerId);
        if (activeTouches.size >= 2) {
          startPinch();
        } else {
          state.pinch = null;
        }
      }
      const wasPanning = state.panning;
      state.draggingPoint = null;
      state.panning = false;
      state.dragHistoryArmed = false;
      if (state.tempPolygon) {
        state.tempPolygon.preview = null;
      }
      if (state.pendingFunctionHighlight && state.tool === 'move' && !wasPanning) {
        const fn = state.functions.find(entry => entry.id === state.pendingFunctionHighlight.id);
        if (fn) {
          setHighlightedFunction(fn.id, { scroll: true, force: true });
        }
      }
      state.pendingFunctionHighlight = null;
      state.panCandidate = null;
    }

    function handleConstructionTool(world) {
      const snappedWorld = snapWorldToGrid(world);
      let point = findPointNear(snappedWorld);
      if (!point) {
        point = createPoint(snappedWorld);
      }
      state.tempPoints.push(point.id);

      if (state.tool === 'line' && state.tempPoints.length === 2) {
        const [p1, p2] = state.tempPoints;
        recordHistory();
        state.lines.push({ id: crypto.randomUUID(), p1, p2 });
        registerAlgebraEntry(state.lines[state.lines.length - 1].id, `l: lijn(${pointName(p1)}, ${pointName(p2)})`, 'line');
        state.tempPoints = [];
        draw();
      }

      if (state.tool === 'segment' && state.tempPoints.length === 2) {
        const [p1, p2] = state.tempPoints;
        recordHistory();
        state.segments.push({ id: crypto.randomUUID(), p1, p2 });
        registerAlgebraEntry(state.segments[state.segments.length - 1].id, `s: segment(${pointName(p1)}, ${pointName(p2)})`, 'segment');
        state.tempPoints = [];
        draw();
      }

      if (state.tool === 'circle' && state.tempPoints.length === 2) {
        const [center, edge] = state.tempPoints;
        recordHistory();
        state.circles.push({ id: crypto.randomUUID(), center, edge });
        registerAlgebraEntry(state.circles[state.circles.length - 1].id, `c: cirkel(${pointName(center)}, ${pointName(edge)})`, 'circle');
        state.tempPoints = [];
        draw();
      }
    }

    function handlePolygonTool(world) {
      if (!state.tempPolygon) {
        state.tempPolygon = { points: [], preview: null, createdPoints: [] };
      } else {
        state.tempPolygon.preview = null;
      }
      const snappedWorld = snapWorldToGrid(world);
      let point = findPointNear(snappedWorld);
      if (!point) {
        point = createPoint(snappedWorld);
        if (point && state.tempPolygon) {
          state.tempPolygon.createdPoints.push(point.id);
        }
      }
      state.tempPolygon.points.push(point.id);
      if (state.tempPolygon.points.length > 2 && point.id === state.tempPolygon.points[0]) {
        const uniquePoints = [...new Set(state.tempPolygon.points.slice(0, -1))];
        if (uniquePoints.length >= 3) {
          recordHistory();
          const polygon = { id: crypto.randomUUID(), points: uniquePoints };
          state.polygons.push(polygon);
          registerAlgebraEntry(polygon.id, `p: veelhoek(${uniquePoints.map(pointName).join(', ')})`, 'polygon');
        }
        state.tempPolygon = null;
        draw();
      }
    }

    function handleTextTool(world) {
      const content = prompt('Tekstinhoud:');
      if (!content) return;
      recordHistory();
      const label = {
        id: crypto.randomUUID(),
        content,
        position: world
      };
      state.texts.push(label);
      registerAlgebraEntry(label.id, `tekst: "${content}"`, 'text');
      draw();
    }

    function pointName(id) {
      const point = state.points.find(p => p.id === id);
      return point ? point.name : '?';
    }

    function handleWheel(event) {
      event.preventDefault();
      const delta = -event.deltaY;
      const factor = delta > 0 ? 1.1 : 0.9;
      const mouse = screenToWorld(event.offsetX, event.offsetY);
      state.scale = clampScale(state.scale * factor);
      const after = worldToScreen(mouse);
      state.origin.x += event.offsetX - after.x;
      state.origin.y += event.offsetY - after.y;
      draw();
    }

    function zoom(factor) {
      const center = {
        x: canvas.clientWidth / 2,
        y: canvas.clientHeight / 2
      };
      const worldCenter = screenToWorld(center.x, center.y);
      state.scale = clampScale(state.scale * factor);
      const after = worldToScreen(worldCenter);
      state.origin.x += center.x - after.x;
      state.origin.y += center.y - after.y;
      draw();
    }

    function resetView() {
      recordHistory();
      state.scale = 80;
      state.origin = { x: canvas.clientWidth / 2, y: canvas.clientHeight / 2 };
      draw();
    }

    function parseCommand(command) {
      const trimmed = command.trim();
      if (!trimmed) return;

      if (!trimmed.includes('=') && /x/i.test(trimmed)) {
        parseCommand(`y = ${trimmed}`);
        return;
      }

      const editingId = state.editingFunctionId;
      const editingIndex = editingId ? state.functions.findIndex(fn => fn.id === editingId) : -1;
      const editingFn = editingIndex >= 0 ? state.functions[editingIndex] : null;

      const pointMatch = trimmed.match(/^([A-Za-z]+)\s*=\s*\(([-+]?\d*\.?\d+),\s*([-+]?\d*\.?\d+)\)$/);
      if (pointMatch) {
        const [, name, x, y] = pointMatch;
        const point = createPoint({ x: parseFloat(x), y: parseFloat(y) }, name, { snap: false });
        updatePointAlgebra(point);
        draw();
        state.editingFunctionId = null;
        return;
      }

      const equationMatch = trimmed.match(/^([^=]+)=\s*(.+)$/);
      if (equationMatch) {
        const leftRaw = equationMatch[1].trim();
        const rightRaw = equationMatch[2].trim();
        const sanitizedLeft = leftRaw.replace(/\s+/g, '');

        const functionCallMatch = sanitizedLeft.match(/^([a-zA-Z][a-zA-Z0-9_]*)\(([a-zA-Z])\)$/);
        const simpleNameMatch = sanitizedLeft.match(/^([a-zA-Z][a-zA-Z0-9_]*)$/);

        let algebraLabel;
        let graphLabel;
        let evaluationExpression = rightRaw;

        if (sanitizedLeft.toLowerCase() === 'y') {
          if (editingFn) {
            algebraLabel = editingFn.algebraLabel;
            graphLabel = editingFn.label;
          } else {
            const generated = nextFunctionLabel();
            algebraLabel = generated;
            graphLabel = generated;
          }
        } else if (functionCallMatch) {
          const [, name, variable] = functionCallMatch;
          const variablePattern = new RegExp(`\\b${variable}\\b`, 'gi');
          evaluationExpression = rightRaw.replace(variablePattern, 'x');
          algebraLabel = `${name}(${variable})`;
          graphLabel = `${name}(x)`;
        } else if (simpleNameMatch) {
          const name = simpleNameMatch[1];
          algebraLabel = `${name}(x)`;
          graphLabel = `${name}(x)`;
        } else {
          const generated = nextFunctionLabel();
          algebraLabel = generated;
          graphLabel = generated;
        }

        if (editingFn) {
          recordHistory();
          state.functions.splice(editingIndex, 1);
          removeAlgebraEntry(editingFn.id);
          const updated = registerFunction({
            algebraLabel,
            expression: rightRaw,
            source: trimmed,
            graphLabel,
            evaluationExpression
          }, {
            id: editingFn.id,
            color: editingFn.color,
            displayName: editingFn.displayName,
            skipHistory: true,
            skipDraw: true,
            skipColorAdvance: true,
            skipAlgebra: true
          });
          if (updated) {
            state.functions.pop();
            state.functions.splice(editingIndex, 0, updated);
            registerAlgebraEntry(updated.id, `${algebraLabel} = ${rightRaw}`, 'function', updated.color);
            setHighlightedFunction(updated.id, { scroll: true, force: true });
          } else {
            state.functions.splice(editingIndex, 0, editingFn);
            registerAlgebraEntry(editingFn.id, `${editingFn.algebraLabel} = ${editingFn.expression}`, 'function', editingFn.color);
            if (state.highlightedFunctionId === editingFn.id) {
              setHighlightedFunction(editingFn.id, { scroll: true, force: true });
            }
          }
          state.editingFunctionId = null;
          draw();
          return;
        }

        registerFunction({
          algebraLabel,
          expression: rightRaw,
          source: trimmed,
          graphLabel,
          evaluationExpression
        });
        state.editingFunctionId = null;
        return;
      }

      alert('Deze opdracht wordt nog niet ondersteund.');
    }

    function initTools() {
      document.querySelectorAll('.tool-button[data-tool]').forEach(btn => {
        btn.addEventListener('click', () => setTool(btn.dataset.tool));
      });
    }

    function initSidebar() {
      toggleSidebarBtn.addEventListener('click', () => {
        if (window.innerWidth < 920) {
          const open = !document.body.classList.contains('sidebar-open');
          document.body.classList.toggle('sidebar-open', open);
          sidebar.classList.toggle('hidden', !open);
        } else {
          const collapsed = document.body.classList.toggle('sidebar-collapsed');
          sidebar.classList.toggle('collapsed-desktop', collapsed);
          sidebar.classList.remove('hidden');
          requestAnimationFrame(resizeCanvas);
        }
        ensureMoveTool();
      });
      closeSidebarBtn.addEventListener('click', () => {
        if (window.innerWidth < 920) {
          document.body.classList.remove('sidebar-open');
          sidebar.classList.add('hidden');
        } else {
          document.body.classList.add('sidebar-collapsed');
          sidebar.classList.add('collapsed-desktop');
          sidebar.classList.remove('hidden');
          requestAnimationFrame(resizeCanvas);
        }
        ensureMoveTool();
      });
    }

    algebraList.addEventListener('click', event => {
      const button = event.target.closest('.delete-button');
      if (button) {
        const item = button.closest('.algebra-item');
        if (!item) return;
        removeObject(item.dataset.id, item.dataset.type);
        ensureMoveTool();
        return;
      }
      const item = event.target.closest('.algebra-item');
      if (!item) return;
      if (item.dataset.type === 'function') {
        const fn = state.functions.find(entry => entry.id === item.dataset.id);
        if (!fn) return;
        state.editingFunctionId = fn.id;
        const source = fn.source || `${fn.algebraLabel} = ${fn.expression}`;
        commandInput.value = source;
        const position = source.length;
        commandInput.setSelectionRange(position, position);
        focusCommandInput();
        setHighlightedFunction(fn.id, { scroll: true, force: true });
        if (isCoarsePointer && !keyboardVisible) {
          setKeyboardVisibility(true);
        }
      }
      ensureMoveTool();
    });

    if (quickActions) {
      quickActions.addEventListener('click', event => {
        const button = event.target.closest('.quick-action');
        if (!button) return;
        applyQuickAction(button.dataset.value || '');
        ensureMoveTool();
      });
    }

    canvas.addEventListener('pointerdown', handlePointerDown);
    window.addEventListener('pointermove', handlePointerMove);
    window.addEventListener('pointerup', handlePointerUp);
    window.addEventListener('pointercancel', handlePointerUp);
    canvas.addEventListener('wheel', handleWheel, { passive: false });

    function handleResponsiveSidebar() {
      if (window.innerWidth < 920) {
        const open = document.body.classList.contains('sidebar-open');
        sidebar.classList.toggle('hidden', !open);
        sidebar.classList.remove('collapsed-desktop');
      } else {
        document.body.classList.remove('sidebar-open');
        const collapsed = document.body.classList.contains('sidebar-collapsed');
        sidebar.classList.toggle('collapsed-desktop', collapsed);
        sidebar.classList.remove('hidden');
      }
    }

    window.addEventListener('resize', () => {
      handleResponsiveSidebar();
      if (window.innerWidth >= 920 && !keyboardBuilt) {
        ensureKeyboardBuilt();
      }
      positionFloatingKeyboard();
      resizeCanvas();
    });

    document.getElementById('zoom-in').addEventListener('click', () => {
      zoom(1.2);
      ensureMoveTool();
    });
    document.getElementById('zoom-out').addEventListener('click', () => {
      zoom(0.8);
      ensureMoveTool();
    });
    document.getElementById('reset-view').addEventListener('click', () => {
      resetView();
      ensureMoveTool();
    });

    if (undoButton) {
      undoButton.addEventListener('click', event => {
        event.preventDefault();
        undo();
        ensureMoveTool();
      });
    }

    if (redoButton) {
      redoButton.addEventListener('click', event => {
        event.preventDefault();
        redo();
        ensureMoveTool();
      });
    }

    keyboardToggle.addEventListener('pointerdown', event => {
      event.preventDefault();
      keyboardToggle.focus();
      ensureMoveTool();
      setKeyboardVisibility(!keyboardVisible);
      skipNextKeyboardToggleClick = true;
    });

    keyboardToggle.addEventListener('click', event => {
      event.preventDefault();
      if (skipNextKeyboardToggleClick) {
        skipNextKeyboardToggleClick = false;
        return;
      }
      setKeyboardVisibility(!keyboardVisible);
    });

    keyboardToggle.addEventListener('keydown', event => {
      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        setKeyboardVisibility(!keyboardVisible);
        skipNextKeyboardToggleClick = true;
      }
    });

    commandInput.addEventListener('focus', () => {
      ensureMoveTool();
      if (window.innerWidth < 920 && !keyboardVisible) {
        setKeyboardVisibility(true);
      }
    });

    commandInput.addEventListener('pointerdown', event => {
      ensureMoveTool();
      if (!isCoarsePointer) return;
      event.preventDefault();
      focusCommandInput();
      const position = commandInput.value.length;
      commandInput.setSelectionRange(position, position);
      if (!keyboardVisible) {
        setKeyboardVisibility(true);
      }
    });

    commandInput.addEventListener('touchstart', event => {
      ensureMoveTool();
      if (window.PointerEvent) return;
      if (!isCoarsePointer) return;
      event.preventDefault();
      focusCommandInput();
      const position = commandInput.value.length;
      commandInput.setSelectionRange(position, position);
      if (!keyboardVisible) {
        setKeyboardVisibility(true);
      }
    }, { passive: false });

    if (keyboardHandle) {
      keyboardHandle.addEventListener('pointerdown', startKeyboardDrag);
    }

    if (keyboard) {
      keyboard.addEventListener('pointermove', updateKeyboardDrag);
      keyboard.addEventListener('pointerup', endKeyboardDrag);
      keyboard.addEventListener('pointercancel', endKeyboardDrag);
      keyboard.addEventListener('lostpointercapture', () => {
        keyboardDragState.active = false;
        keyboardDragState.pointerId = null;
        keyboard.classList.remove('dragging');
      });
    }

    document.addEventListener('pointerdown', event => {
      if (!keyboardVisible) return;
      const target = event.target;
      if (keyboard.contains(target)) return;
      if (keyboardToggle.contains(target)) return;
      if (commandBar && commandBar.contains(target)) return;
      setKeyboardVisibility(false);
    });

    window.addEventListener('keydown', event => {
      if ((event.ctrlKey || event.metaKey) && !event.altKey) {
        const key = event.key.toLowerCase();
        if (key === 'z') {
          event.preventDefault();
          if (event.shiftKey) {
            redo();
          } else {
            undo();
          }
        } else if (key === 'y') {
          event.preventDefault();
          redo();
        }
      }
    });

    window.addEventListener('keydown', event => {
      if (event.key === 'Escape' && keyboardVisible) {
        setKeyboardVisibility(false);
      }
    });

    commandInput.addEventListener('keydown', event => {
      if (event.key === 'Enter') {
        parseCommand(commandInput.value);
        commandInput.value = '';
      } else if (event.key === 'Escape') {
        setKeyboardVisibility(false);
      }
    });

    if ('ResizeObserver' in window) {
      const resizeObserver = new ResizeObserver(() => resizeCanvas());
      resizeObserver.observe(graphContainer);
    }

    updateInputMode();
    if (typeof coarsePointerMedia.addEventListener === 'function') {
      coarsePointerMedia.addEventListener('change', handlePointerPreferenceChange);
    } else if (typeof coarsePointerMedia.addListener === 'function') {
      coarsePointerMedia.addListener(handlePointerPreferenceChange);
    }

    const standaloneMedia = window.matchMedia('(display-mode: standalone)');
    function handleDisplayModeChange(event) {
      if (event.matches) {
        enforceStandaloneViewport();
      } else {
        restoreViewport();
      }
    }

    if (standaloneMedia.matches || window.navigator.standalone) {
      enforceStandaloneViewport();
    }
    if (typeof standaloneMedia.addEventListener === 'function') {
      standaloneMedia.addEventListener('change', handleDisplayModeChange);
    } else if (typeof standaloneMedia.addListener === 'function') {
      standaloneMedia.addListener(handleDisplayModeChange);
    }
    window.addEventListener('appinstalled', enforceStandaloneViewport);

    if (commandBar) {
      commandBar.style.display = 'flex';
      commandBar.removeAttribute('hidden');
    }

    if (window.innerWidth >= 920) {
      ensureKeyboardBuilt();
    }

    initTools();
    initSidebar();
    if (window.innerWidth < 920) {
      sidebar.classList.add('hidden');
    }
    handleResponsiveSidebar();
    updateUndoRedoButtons();
    buildQuickActions();
    resizeCanvas();
  </script>
</body>
</html>
